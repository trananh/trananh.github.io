---
layout: post
title: Preparing for a Google [Phone] Interview

location: Tucson, AZ
excerpt: Ever wanted to know what it's like to prepare for a phone interview with Google?  How much preparation is
        enough?  What should you focus on?  Well, I don't have an official answer for either question.  What I
        can offer though, is a brief overview of how I prepared for my interview and a pool of resources
        that I found to be helpful during my review.
category: work

comments: true
---

<p> As we have all been led to believe at one point or another, a job interview with Google is not something to take
    lightly.  Regardless of how busy you are, you will want to allocate plenty of time to prepare for the interview.
    Given my preparation experience, I think it's best to spend <i>at least</i> a week to prepare. I know of some who
    have spent well over a month studying.  I personally could only spare a few days (and had to skip a few topics).
    Everyone is different but when time is of the essence, remember: <i>A little bit of something is still better
    than nothing!</i>
</p>
<p> If you absolutely have no time to spare, however, perhaps it would be best to reschedule your
    interview to a time when you do. In most cases, your interviewers should be more than willing to accommodate
    for your needs.
</p>

<p> I cannot comment on the best preparation strategies.  I can, however, tell you how I prepared for my phone
    interview and discuss the materials that I reviewed.  Hopefully these resources will give you a leg up on
    your own preparation process.
</p>



<h2>Coding</h2>
<p>
    First and foremost, you will need to know how to code and be able to do it well! Be sure to brush up heavily on
    your language of choice. The first thing I did, per <b>strong</b> recommendation from the recruiter, was looking
    up the book <a href="http://www.wiley.com/WileyCDA/WileyTitle/productCd-047012167X.html" target="_blank">
    [Programming Interviews Exposed: Secrets to Landing Your Next Job]</a>, by John Mongan, Noah Kindler,
    and Eric Gigu√®re. I must say, it was a fantastic read and I highly recommend the book myself.  If you are
    associated with a University, don't be surprised to find it in your school's library. (I did.)
</p>
<p>
    Asides from reading the book, I also aggressively reviewed my programming language of choice.  The primary language
        for my interview was Java so naturally I Googled for "advanced Java tutorials."  If you're already a seasoned
        developer, then you should be fine.  If you're someone like me who constantly switches between multiple
        different languages, then a refresher course is definitely good idea.  Remember, during the phone interview
        you will need to program in a Google doc, without the aid of an IDE!!  Here are some Java tutorials that
        I found to be useful:

    <ul>
        <li><a href="http://www.tutorialspoint.com/java/" target="_blank">[Java tutorial]</a> from tutorialspoint.com
            is pretty basic, but can serve as a very good and quick refresher course.  They even have a nice list of
            of <a href="http://www.tutorialspoint.com/java/java_interview_questions.htm" target="_blank">Java
            interview questions</a>.
        </li>
        <li>Oracle.com provides a very good <a href="http://docs.oracle.com/javase/tutorial/java/" target="_blank">
            [tutorial trail]</a>.  In my opinions, these examples are a little more advanced and provide more depths
            than the first option.
        </li>
        <li>Finally, I strongly recommend the blog at <a href="http://javarevisited.blogspot.com/" target="">
            [javarevisted]</a>.  The author covers many advanced technical questions, such as: the difference between
            <a href="http://javarevisited.blogspot.com/2010/10/difference-between-hashmap-and.html"
            target="_blank">HashMap vs Hashtable</a>, the
            <a href="http://javarevisited.blogspot.com/2011/02/how-hashmap-works-in-java.html" target="_blank">
            innerworking of HashMap</a>, differences between
            <a href="http://javarevisited.blogspot.sg/2011/06/top-programming-interview-questions.html"
            target="_blank">Vector vs ArrayList</a>, why
            <a href="http://javarevisited.blogspot.com/2010/10/why-string-is-immutable-in-java.html" target="_blank">
            String is immutable and final</a>, and many others.
        </li>
    </ul>
</p>
<p>
    Time permitted, you should also consider opening up a good Java programming cookbook, like
    <a href="http://shop.oreilly.com/product/9780596007010.do" target="_blank">[this one]</a>. I didn't have time
    for this myself, but it's a good idea nonetheless.
</p>



<h2>Algorithm Complexity</h2>
<p>
    Know thy Big-O's!!  Or at the very least, know what it means and know how to analyze an algorithm
    for its <b>time and space</b> complexity.  Although in academia you may have focused more on time complexity,
    often at the cost of space complexity, I would imagine that at Google one cannot afford to overlook space
    efficiency, especially when dealing with millions or billions of data points.  <i>I can almost guarantee that
    your chance of getting hired is slim to none if you don't know about Big-O.</i> So here are some good resources
    that helped me:

    <ul>
        <li>
            Wikipedia does a very nice job summarizing the
            <a href="http://en.wikipedia.org/wiki/Big_O_notation" target="_blank">[Big-O]</a> notation. While brushing
            up on Big-O, be sure to refresh your understanding of Big-Omega and Big-Theta.
        </li>
        <li>
            You may also find this <a href="http://bigocheatsheet.com/" target="_blank">[Big-O cheat sheet]
            </a>to be useful.  Personally, I think it's nice to have, but not helpful for an interview.
            An interviewer is likely more interested on whether or not you know how to derive a time complexity,
            rather than your ability to memorize one.
        </li>
        <li>
            Again, if you have time, it's worth hitting the book.  Here's a good option:
            <a href="http://it-ebooks.info/book/1608/" target="_blank">[An Introduction to the Analysis of
            Algorithms]</a>. Best of all, the e-version is free (at the time of this post)!
        </li>
    </ul>
</p>
<p>
    Along with algorithm complexities, I think it's also very important to know about complexity classes.  In my
    humbling opinions, all interviewing computer scientists should be expected to know about NP-completeness and its
    implications. If you don't know or could use a reminder of the definition, Wikipedia has you covered
    <a href="http://en.wikipedia.org/wiki/NP-complete" target="_blank">[here]</a>. I also think it is
    practical to know about common/popular NP-complete and NP-hard problems, see this
    <a href="http://en.wikipedia.org/wiki/List_of_NP-complete_problems" target="_blank">[list]</a>. Hold up, pop quiz:
    <i>what is the difference between NP-hard and NP-complete anyway?</i>
</p>
<p> There are other complexity classes as well.  Unless you're specifically interviewing for a position that
    deals with advanced algorithms, I think it suffices to know about what they are and not their details (or
    at least I hope that is the case).  For the curious minds though, here is another good read on
    <a href="http://www.cs.berkeley.edu/~vazirani/algorithms/chap8.pdf" target="_blank">[NP-completeness]</a>.
</p>
<p>
    Finally, you will want to look at some example algorithm problems.  My recruiter suggested
    <a href="http://community.topcoder.com/tc?module=Static&d1=tutorials&d2=alg_index" target="_blank">[topcoder]</a>.
    These are certainly worth a look if you have time.
</p>



<h2>Sorting</h2>
<p>
    Sorting is one of the most fundamental problems in Computer Science, so you should know it by heart.  One should
    understand why sorts like <a href="http://en.wikipedia.org/wiki/Bubble_sort" target="_blank">[bubble sort]</a>
    and <a href="http://en.wikipedia.org/wiki/Insertion_sort" target="_blank">[insertion sort]</a> are inefficient.
    Naturally, this means knowing about better sorting methods, such as <a href="http://en.wikipedia.org/wiki/Quicksort"
    target="_blank">[quicksort]</a> or <a href="http://en.wikipedia.org/wiki/Merge_sort" target="_blank">[mergesort]
    </a>.
</p>
<p>
    I found from experience that merge sort can be very useful in situations where quicksort is impractical. Here is a
    variation of a popular interview question that I've had in the past: <i>Given a file with 1,000,000,000
    integers, sort the integers using  only 1 MB of memory space.</i>  Give up?  Here's a
    <a href="http://en.wikipedia.org/wiki/External_sorting" target="_blank">[hint]</a> if you need it.
    Feel free to share your solution below.  If there are enough interests, I will consider posting my solution at
    a later time.
</p>
<p>
    Lastly, did you know that in general no comparison sort algorithms can do better than <i>O(n</i>&nbsp;log<i>n)</i>?
    Why do you think that is?
</p>



<h2>Hashtables</h2>
<p>
    Arguably, the single most used and important data structure in our toolbox.  You should absolutely know
    how they work.  My recruiter suggested that one should be able to implement a hash table using only arrays in the
    space of one interview.  Clearly your implementation wouldn't be groundbreaking (though, it could be!),
    but it should be functional at least.
</p>
<p>
    To implement a hash table, you will need to understand how it works.  Once again, Wikipedia knows best. Here's
    the <a href="http://en.wikipedia.org/wiki/Hash_table" target="_blank">[link]</a>.  If you're like me, you probably
    learned about hash tables at some point, so now is a good time to refresh your memory.  If terms like load factor,
    item buckets, and hash collisions sound foreign to you, then it is time to hit the book.  I had to reviewed
    the different ways of handling hash collisions and how to keep the number of collisions low.  More importantly,
    I had to investigate how Java implemented its version of a hash table.  On a related note, I also needed to
    looked up different <a href="http://en.wikipedia.org/wiki/Hash_function" target="_blank">[hash functions]</a>.
</p>
<p>
    Finally, does your language of choice support hash tables? A hash table is sometimes called a dictionary in some
    languages.  If your primary programming language supports multiple implementations of a hash table, such as
    Java's <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html" target="_blank">Hashtable</a>,
    <a href="http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html" target="-blank">HashMap</a>,
    <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html" target="_blank">
        ConcurrentHashMap</a>,
    <a href="http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html" target="_blank">TreeMap</a>, and
    <a href="http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html" target="_blank">LinkedHashMap</a>,
    then you should absolutely learn the differences between them.
</p>


<h2>Trees</h2>
<p>
    The <a href="http://www.wiley.com/WileyCDA/WileyTitle/productCd-047012167X.html" target="_blank">
    [book]</a> I mentioned above contains a very informative section on Trees, specifically binary trees.
    For more general information regarding trees, I once again suggest visiting Wikipedia's entry on
    <a href="http://en.wikipedia.org/wiki/Binary_tree" target="_blank">[Trees]</a>.  Here's another good
    introduction on <a href="http://www.cs.cmu.edu/~adamchik/15-121/lectures/Trees/trees.html" target="_blank">[Trees
    from CMU]</a>.
</p>
<p> Random pop quiz #2: <i>Do you still remember how to <a href="http://en.wikipedia.org/wiki/Tree_rotation"
    target="_blank">[rotate a tree]</a>?</i>
</p>
<p>
    You should know the usefulness of a binary search tree (BST) and know that an unbalanced BST is about as
    efficient as a linked list (not very efficient at all!). So how can we keep a BST balanced?  The recruiter
    recommended that I know about at least one <a href="http://en.wikipedia.org/wiki/Self-balancing_binary_search_tree"
    target="_blank">[self-balancing BST]</a>.  I found the
    <a href="http://en.wikipedia.org/wiki/Splay_tree" target="_blank">[splay tree]</a> to be simplest to learn,
    but you may prefer the more popular <a href="http://en.wikipedia.org/wiki/Red-black_tree" target="_blank">
    [red-black tree]</a>.
</p>



<h2>Graphs</h2>
<p>
    Along with trees, graphs are the fundamental representation of many interesting problems.  These problems are
    especially prevalent at Google. There are three basic ways to represent a graph in memory (objects and pointers,
    matrix, and adjacency list) and you should know about all three, including their pros and cons.  Here's a good
    review on <a href="http://www.geeksforgeeks.org/graph-and-its-representations/" target="_blank">[graph
    representations]</a> (keep in mind that an adjacency list also uses objects and pointers).
</p>
<p>
    Graphs are often traversed using breadth-first search (BFS) or depth-first search (DFS).  If these don't sound
    familiar to you, then that's a very good indicator for what you need to study.  Wikipedia does a decent job
    describing <a href="http://en.wikipedia.org/wiki/Graph_traversal" target="_blank">[graph traversals]</a>.  Here is a
    better <a href="http://www.cs.cornell.edu/courses/CS2112/2012sp/lectures/lec24/lec24-12sp.html" target="_blank">
    [introduction]</a>. Graph traversal algorithms are often used in graph searching problems.  Of those,
    there are two common algorithms for finding the shortest path that you should learn about if you have time:
    <a href="http://en.wikipedia.org/wiki/Dijkstra's_algorithm" target="_blank">[Dijkstra]</a> and
    <a href="http://en.wikipedia.org/wiki/A*_search_algorithm" target="_blank">[A*]</a> (pronounces "A star").  I
    personally love A*; so simple and elegant, yet so powerful.
</p>
<p>
    Here's a checkpoint, do you know the differences between in-order, pre-order, and post-order traversals?
    How about topological order?  Personally, I had to review
    <a href="http://en.wikipedia.org/wiki/Topological_sorting" target="_blank">[Topological sorting]</a> and I
    suggest that you do the same if needed.  Topological ordering plays a crucial role in directed-acyclic graph
    (DAG) searching.
</p>
<p>
    It's worth mentioning that there is a huge number of interesting graph problems out there! Knowing some of these
    may work to your advantage.  I had the opportunity to take an advanced algorithms class last semester and learned
    a lot about graph theory and algorithms (and I loved it!). These are purely for curiosity fulfillment, of course.
    Here is a good <a href="http://www.math.uiuc.edu/~west/openp/" target="_blank">[list of graph problems]</a> for
    those interested.
</p>


<h2>Other Data Structures</h2>
<p>
    There are many other data structures out there that we have not mentioned.  Some are common household names,
    such as the heap, queue, stack, list, and array, while others are lesser known but can be very useful
    under the right circumstances, such as the
    <a href="http://en.wikipedia.org/wiki/Skip_list" target="_blank">[skip-list]</a>,
    <a href="http://en.wikipedia.org/wiki/Trie" target="_blank">[trie]</a>, and
    <a href="http://en.wikipedia.org/wiki/Disjoint-set_data_structure" target="_blank">[disjoint-set]</a>.
    Here are some useful notes on <a href="http://www.cs.sunysb.edu/~skiena/214/lectures/" target="_blank">
    [common data structures]</a> from an instructor at Stony Brook University, and here is a fun thread
    from stackoverflow.com about
    <a href="http://stackoverflow.com/questions/500607/what-are-the-lesser-known-but-useful-data-structures"
    target="_blnk">[lesser known data structures]</a>.
</p>
<p>
    If you're pressed for time, though, please don't waste any studying the less mainstream data structures!
</p>
<p>
    Lastly, while studying up on different data structures.  Make sure you pay close attention to their pros and cons,
    and know the complexity of their operations.  Most data structures are designed to optimize certain operations,
    often at the cost of others.  It's hard to design a one-fit-all data structure.
</p>



<h2>Mathematics</h2>
<p>
    It was emphasized to me that counting problems, probability problems, and other Discrete Math 101 problems are
    especially prevalent at Google.  That means it is definitely a good idea to brush up on your math.
</p>
<p>
    I think
    <a href="http://en.wikipedia.org/wiki/Combination" target="_blank">[combination]</a> and
    <a href="http://en.wikipedia.org/wiki/Permutation" target="_blank">[permutation]</a> problems are quite
    popular since they are very relatable to coding problems.  For example, you might be asked to
    find all <a href="http://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/"
    target="_blank">[permutations of a string]</a> - a classic permutation problem with many real-world applications.
</p>
<p>
    In my line of research, statistics and probabilities are extremely important!  Knowing basic statistics and
    probability theories will carry you far.  Time permitted, you should refresh your statistics.
</p>
<p>
    Lastly, if you have the time for it, here's a good site that covers various aspects of
    <a href="http://math.about.com/od/discretemath/" target="_blank">[discrete mathematics]</a>.
</p>



<h2>Example Questions & Experiences</h2>
<p>
    Lastly, I think one should definitely get plenty of practice answering interview questions.  Experience
    is invaluable and practice makes perfect!  You should spend any extra time practicing interview questions.
    There are many different resources that you can use on the web.  Here are a few good ones to get
    you started:

    <ul>
        <li>Topcode.com is a good source for <a href="http://www.topcoder.com/tc?module=Static&d1=tutorials&d2=alg_index"
            target="_blank">[algorithm problems]</a>.
        </li>
        <li>Geeksforgeeks.org provides a very good list of <a href="http://www.geeksforgeeks.org/tag/interview-experience/"
            target="_blank">[interview experiences]</a>.
        </li>
        <li>Javarevisited.blogspot.com composed a nice list of
            <a href="http://javarevisited.blogspot.com/2011/06/top-programming-interview-questions.html"
            target="_blank">[Java interview questions]</a>.
        </li>
        <li>Glassdoor.com also has some interview questions shared by other
            <a href="http://www.glassdoor.com/Interview/Google-Interview-Questions-E9079.htm" target="_blank">
            [Google interviewees]</a>.
        </li>
    </ul>
</p>
<p>
    Also, don't pass up the chance to read experiences shared by others who have gone through the process. Knowing
    their insights could help increase your chances of doing well.

    <ul>
        <li><a href="http://www.philosophicalgeek.com/2007/08/12/my-interview-experience-with-google/" target="_blank">
            philosophicalgeek.com</a>
        </li>
        <li><a href="http://miki.it/blog/2013/9/18/google-interview-vs-facebook-interview/" target="_blank">
            miki.it/blog</a>
        </li>
        <li><a href="http://www.globalnerdy.com/2013/10/19/i-has-the-dumb-or-how-i-embarrassed-myself-in-my-interview-with-google/"
            target="_blank">globalnerdy.com</a>
        </li>
        <li><a href="http://symbo1ics.com/blog/?p=2055" target="_blank">symbo1ics.com</a>
        </li>
    </ul>
</p>



<h2>Summary</h2>
<p>
    That's about it for now.  While the list of materials may seem daunting at first, rest assured that with good time
    management and sufficient willpower, it can be done in a reasonable amount of time.  Feel free to skip any sections
    that may be redundant for you.  The bottom line is, start early and give yourself plenty of time to prepare.
    Proper preparation is the key to success.
</p>
<p>
    Lastly, I wish you the best of luck on your interview.
</p>
<p>
    <i>Did you find my list of resources helpful or have you found some helpful links that I should include?
        Please leave a comment below and let me know about it.</i>
</p>
