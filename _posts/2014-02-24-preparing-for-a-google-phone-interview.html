---
layout: post
title: Preparing for a Google [Phone] Interview

location: Tucson, AZ
excerpt: Ever wanted to know what it's like to prepare for a phone interview with Google?  How much preparation is
        enough?  What should you focus on?  Well, I don't have an official answer for either question.  What I
        can offer though, is a brief overview of how I prepared for my interview and a pool of resources
        that I found to be helpful.
category: work

comments: true
---

<p> Do you have a phone interview with Google on the schedule?  Or any software engineering job interview
    for that matter?  If so, then congratulations!  You've made the most important step of getting your foot
    in the door.  Now let's make sure we don't squander this opportunity.
</p>
<p>
    As with any big performances in life, proper mental preparation can often mean the difference between success
    and failure.  It is imperative that you allocate enough time in your busy (or not so busy) schedule
    to properly review for the "big dance."  In my experience, it's best to spend <i>at least</i> a week to prepare.
    Most people often spend a few weeks and I know of some who have spent well over a month studying.
    Everyone is different but when time is of the essence, remember:
    <i>A little bit of something is still better than nothing!</i>
</p>

<p> While I cannot comment on the best preparation strategies; I can, however, describe how I got ready for my phone
    interview and layout the different materials that I chose to cover.  Hopefully the resources that I list
    here will give you a head start in your own preparation process. Some of the materials are specific to my
    interview process, but most are general and apply to all software development positions.
</p>

<p> Note that if you absolutely have no time to spare, however, it might be wise to reschedule your
    interview for a later date. In most cases, your interviewers should be more than willing to accommodate
    for your needs.
</p>

<p>
    Now here we go, in no particular order ...
</p>



{% assign count = 0 %}

<hr/>
{% assign count = count | plus:1 %}
<h2>{{count}}.&nbsp;Coding</h2>
<p>
    First and foremost, you will need to know how to code (well, duh)! The first thing I did, per <b>strong</b>
    recommendation from the recruiter, was looking
    up the book <a href="http://www.wiley.com/WileyCDA/WileyTitle/productCd-047012167X.html" target="_blank">
    [Programming Interviews Exposed: Secrets to Landing Your Next Job]</a>, by John Mongan, Noah Kindler,
    and Eric Gigu√®re.  I must say, it was a fantastic read and I highly recommend the book myself.
    By the way, in most cases, your recruiter's only job is to get you hired, so use that to your advantage!
    Pick their brains for anything of use, such as what to study.
</p>
<p>
    Asides from reading the book, I also aggressively reviewed my primary programming language.  The language of choice
    for my interview was Java so naturally I Googled for "advanced Java tutorials."  If you're already a seasoned
    developer, then you might decide to skip this step.  If you're someone like me who constantly switches between
    multiple different languages, then a refresher course should definitely be on your queue.  Remember, during the
    phone interview you will need to program in a Google doc, without the aid of an IDE!  Here are some Java tutorials
    that I found to be useful:

    <ul>
        <li><a href="http://www.tutorialspoint.com/java/" target="_blank">[Java tutorial]</a> from tutorialspoint.com
            is pretty basic, but can serve as a good and quick introductory.  They even have a nice list of
            of common <a href="http://www.tutorialspoint.com/java/java_interview_questions.htm" target="_blank">Java
            interview questions</a>.
        </li>
        <li>Oracle.com provides a very good <a href="http://docs.oracle.com/javase/tutorial/java/" target="_blank">
            [tutorial trail]</a>.  In my opinions, these examples are a little more advanced and provide more depths
            than the first option.
        </li>
        <li>Finally, I strongly recommend the blog at <a href="http://javarevisited.blogspot.com/" target="">
            [javarevisted]</a>.  The author covers many advanced technical questions, such as: the difference between
            <a href="http://javarevisited.blogspot.com/2010/10/difference-between-hashmap-and.html"
            target="_blank">HashMap vs Hashtable</a>, the
            <a href="http://javarevisited.blogspot.com/2011/02/how-hashmap-works-in-java.html" target="_blank">
            innerworking of HashMap</a>, differences between
            <a href="http://javarevisited.blogspot.sg/2011/06/top-programming-interview-questions.html"
            target="_blank">Vector vs ArrayList</a>, why
            <a href="http://javarevisited.blogspot.com/2010/10/why-string-is-immutable-in-java.html" target="_blank">
            String is immutable and final</a>, and many others.
        </li>
    </ul>
</p>
<p>
    Time permitted, you should also consider opening up a good Java programming cookbook, like
    <a href="http://shop.oreilly.com/product/9780596007010.do" target="_blank">[this one]</a>. There are C/C++,
    C#, Python, Perl, and many other variations as well. I didn't have time for this myself, but it's a good idea
    nonetheless.
</p>



{% assign count = count | plus:1 %}
<h2>{{count}}.&nbsp;Algorithm Complexity</h2>
<p>
    Know thy <b>Big-O</b>'s!  Or at the very least, know what it means and know how to analyze an algorithm
    for the <b>time and space</b> complexity.  Although in academia you may have focused more on time complexity,
    often at the cost of space complexity, I would imagine that at Google one cannot afford to overlook space
    efficiency, especially when dealing with millions or billions of data points.  <i>I can almost guarantee that
    your chance of getting hired is slim to none if you don't know about Big-O.</i> So here are some good resources
    that helped me:

    <ul>
        <li>
            Wikipedia does a very nice job summarizing the
            <a href="http://en.wikipedia.org/wiki/Big_O_notation" target="_blank">[Big-O]</a> notation. While reading
            up on Big-O, be sure to remind yourself of Big-Omega and Big-Theta.
        </li>
        <li>
            You may also find this <a href="http://bigocheatsheet.com/" target="_blank">[Big-O cheat sheet]
            </a>to be useful.  Personally, I think it's nice to have, but not helpful for an interview.
            An interviewer is likely more interested on whether or not you know how to derive a time complexity,
            rather than your ability to memorize one.
        </li>
        <li>
            Again, if you have time, it's worth hitting the book.  Here's a good (reads free) option:
            <a href="http://it-ebooks.info/book/1608/" target="_blank">[An Introduction to the Analysis of
            Algorithms]</a> by Robert Sedgewick and Philippe Flajolet.
        </li>
        <li>
            Another recruiter from Google recommended this book:
            <a href="http://www.amazon.com/Introduction-Design-Analysis-Algorithms-Edition/dp/0132316811"
            target="_blank">[Introduction to the Design and Analysis of Algorithms]</a> by Anany Levitin.
        </li>
    </ul>
</p>
<p>
    Related to algorithm complexities, I think it's also important to know about complexity classes.  In my
    humbling opinions, all interviewing computer scientists should be expected to know about NP-completeness and its
    implications. If you don't know or could use a reminder on the topic, Wikipedia has you covered
    <a href="http://en.wikipedia.org/wiki/NP-complete" target="_blank">[here]</a>. Additionally, it is
    practical to know about common/popular NP-complete and NP-hard problems, see this
    <a href="http://en.wikipedia.org/wiki/List_of_NP-complete_problems" target="_blank">[list]</a>.
</p>
<p>
    Hold up, pop quiz: <i>What is the difference between NP-hard and NP-complete anyway?</i>
</p>

<p> There are other complexity classes as well.  Though unless you're specifically interviewing for a position that
    deals with advanced algorithms, I think it is sufficient to know about what they are and not their details (or
    at least I hope that is the case for my interview).  For the curious minds though, here is another good read on
    <a href="http://www.cs.berkeley.edu/~vazirani/algorithms/chap8.pdf" target="_blank">[NP-completeness]</a>.
</p>
<p>
    Finally, you will want to look at some example algorithm problems and tutorials.  My recruiter suggested
    <a href="http://community.topcoder.com/tc?module=Static&d1=tutorials&d2=alg_index" target="_blank">[topcoder]</a>.
    These are certainly worth a look if you have time.
</p>



{% assign count = count | plus:1 %}
<h2>{{count}}.&nbsp;Sorting</h2>
<p>
    Sorting is one of the most fundamental problems in Computer Science, so you should know it by heart.  One should
    understand why sorts like <a href="http://en.wikipedia.org/wiki/Bubble_sort" target="_blank">[bubble sort]</a>
    and <a href="http://en.wikipedia.org/wiki/Insertion_sort" target="_blank">[insertion sort]</a> are inefficient.
    Naturally, this means knowing about better sorting methods, such as <a href="http://en.wikipedia.org/wiki/Quicksort"
    target="_blank">[quicksort]</a> or <a href="http://en.wikipedia.org/wiki/Merge_sort" target="_blank">[merge sort]
    </a>.
</p>
<p>
    I found from experience that merge sort can be very useful in situations where quicksort is impractical. For
    example, here is a variation of a popular interview question that I've encountered:

    <blockquote>Given a file with 1,000,000,000 random integers, sort the integers in ascending (or descending)
    order using only 1 MB of [runtime] memory space.
    </blockquote>

    Need help?  Here's a <a href="http://en.wikipedia.org/wiki/External_sorting" target="_blank">[hint]</a>.
    Feel free to share your solution below.  If there are enough interests, I will consider posting my solution at
    a later time.
</p>
<p>
    Lastly, did you know that in general no comparison sort algorithms can do better than <i>O(n</i>&nbsp;log<i>n)</i>?
    Why do you think that is?
</p>



{% assign count = count | plus:1 %}
<h2>{{count}}.&nbsp;Hashtables</h2>
<p>
    Arguably, the single most used and important data structure in our toolbox.  You should absolutely know
    how they work.  My recruiter suggested that one should be able to implement a hash table using only arrays in the
    space of one interview.  Clearly your implementation is not expected to be groundbreaking (though, it could be!),
    it should at least be functional.
</p>
<p>
    To implement a hash table, you will need to understand how it works.  Once again, Wikipedia knows best. Here's
    the <a href="http://en.wikipedia.org/wiki/Hash_table" target="_blank">[link]</a>.  If you're like me, you've likely
    learned about hash tables ages ago, so now is a good time to freshen your memory.  If terms like
    <i>load factor</i>, <i>item buckets</i>, and <i>hash collisions</i> sound foreign to you, then it is time to hit
    the book.  I personally had to review the different ways of handling hash collisions and how to keep the number
    of collisions low.  More importantly, I needed to investigate how Java implemented its version of a hash table.
    On a related note, I also studied the different <a href="http://en.wikipedia.org/wiki/Hash_function"
    target="_blank">[hash functions]</a>.
</p>
<p>
    Finally, does your language of choice support hash tables? A hash table is sometimes called a dictionary in some
    languages.  If your primary programming language supports multiple implementations of a hash table, such as
    Java's <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html" target="_blank">Hashtable</a>,
    <a href="http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html" target="-blank">HashMap</a>,
    <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html" target="_blank">
        ConcurrentHashMap</a>,
    <a href="http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html" target="_blank">TreeMap</a>, and
    <a href="http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html" target="_blank">LinkedHashMap</a>,
    then you should absolutely learn the differences between them.
</p>



{% assign count = count | plus:1 %}
<h2>{{count}}.&nbsp;Trees</h2>
<p>
    The <a href="http://www.wiley.com/WileyCDA/WileyTitle/productCd-047012167X.html" target="_blank">
    [book]</a> I mentioned above has a very informative section on Trees, specifically binary trees.
    For more general information regarding trees, I once again suggest visiting the
    <a href="http://en.wikipedia.org/wiki/Binary_tree" target="_blank">[Wikipedia's entry]</a>.  Here's another good
    introduction on <a href="http://www.cs.cmu.edu/~adamchik/15-121/lectures/Trees/trees.html" target="_blank">
    [Trees]</a> from a professor at CMU.
</p>
<p> Random pop quiz #2: <i>Do you still remember how to <a href="http://en.wikipedia.org/wiki/Tree_rotation"
    target="_blank">[rotate a tree]</a>?</i>
</p>
<p>
    You should know the usefulness of a binary search tree (BST) and know that an unbalanced BST is about as
    efficient as a linked list (not very efficient at all!). So how can we keep a BST balanced?  The recruiter
    recommended that I know about at least one <a href="http://en.wikipedia.org/wiki/Self-balancing_binary_search_tree"
    target="_blank">[self-balancing BST]</a>.  I found the
    <a href="http://en.wikipedia.org/wiki/Splay_tree" target="_blank">[splay tree]</a> to be simplest to learn,
    but you may prefer the more popular <a href="http://en.wikipedia.org/wiki/Red-black_tree" target="_blank">
    [red-black tree]</a>.
</p>



{% assign count = count | plus:1 %}
<h2>{{count}}.&nbsp;Graphs</h2>
<p>
    Along with trees, graphs are the fundamental representation of many interesting problems.  These problems are
    especially prevalent at Google. There are three basic ways to represent a graph in memory (objects and pointers,
    matrix, and adjacency list) and you should know about all three, including their pros and cons.  Here's a good
    review on <a href="http://www.geeksforgeeks.org/graph-and-its-representations/" target="_blank">[graph
    representations]</a> (keep in mind that an adjacency list also uses objects and pointers).
</p>
<p>
    Graphs are often traversed using breadth-first search (BFS) or depth-first search (DFS).  If these don't sound
    familiar to you, then that's a very good indicator for what you need to study.  Wikipedia does a decent job
    describing <a href="http://en.wikipedia.org/wiki/Graph_traversal" target="_blank">[graph traversals]</a>.  Here is a
    better <a href="http://www.cs.cornell.edu/courses/CS2112/2012sp/lectures/lec24/lec24-12sp.html" target="_blank">
    [introduction]</a>. Graph traversal algorithms are often used in graph searching problems.  Of those,
    there are two common algorithms for finding the shortest path that you should know about:
    <a href="http://en.wikipedia.org/wiki/Dijkstra's_algorithm" target="_blank">[Dijkstra]</a> and
    <a href="http://en.wikipedia.org/wiki/A*_search_algorithm" target="_blank">[A*]</a> (pronounces "A star").  I
    personally love A*; so simple and elegant, yet so powerful.
</p>
<p>
    Here's a checkpoint, do you know the differences between in-order, pre-order, and post-order traversals?
    How about topological order?  Personally, I had to review
    <a href="http://en.wikipedia.org/wiki/Topological_sorting" target="_blank">[Topological sorting]</a> and I
    suggest that you do the same if needed.  Topological ordering plays a crucial role in directed-acyclic graph
    (DAG) searching.
</p>
<p>
    It's worth mentioning that there is a huge number of interesting graph problems out there! Knowing some of these
    may work to your advantages.  I had the opportunity to take an advanced algorithms class last semester and learned
    a lot about graph theory and algorithms (and I loved it). These are purely for curiosity fulfillment, of course.
    Here is a good <a href="http://www.math.uiuc.edu/~west/openp/" target="_blank">[list of graph problems]</a> for
    those interested.
</p>



{% assign count = count | plus:1 %}
<h2>{{count}}.&nbsp;Other Data Structures</h2>
<p>
    There are many other data structures out there that we have not mentioned.  Some are common household names,
    such as the heap, queue, stack, list, and array, while others are lesser known but can be very useful
    under the right circumstances, such as the
    <a href="http://en.wikipedia.org/wiki/Skip_list" target="_blank">[skip-list]</a>,
    <a href="http://en.wikipedia.org/wiki/Trie" target="_blank">[trie]</a>, and
    <a href="http://en.wikipedia.org/wiki/Disjoint-set_data_structure" target="_blank">[disjoint-set]</a>.
    Here are some useful notes on <a href="http://www.cs.sunysb.edu/~skiena/214/lectures/" target="_blank">
    [common data structures]</a> from a distinguished professor at Stony Brook University, and here is a fun thread
    from stackoverflow.com about
    <a href="http://stackoverflow.com/questions/500607/what-are-the-lesser-known-but-useful-data-structures"
    target="_blnk">[lesser known data structures]</a>.
</p>
<p>
    Though if you're pressed for time, please be selective about what to take on.  Don't waste time, for example,
    studying the less mainstream data structures if you only have a few days to prepare.
</p>
<p>
    Lastly, while reading up on different data structures.  Make sure you pay close attention to their pros and cons,
    and know the complexities of their implementations.  Most data structures are designed to optimize certain
    operations, often at the cost of others.  It's hard to design a one-fit-all data structure.
</p>



{% assign count = count | plus:1 %}
<h2>{{count}}.&nbsp;Operating Systems</h2>
<p>
    It would be a good idea to know about <a href="http://en.wikipedia.org/wiki/Operating_system"
    target="_blank">[Operating Systems]</a>.  No, not how to use them, but how they work.  Know the important
    parts of an OS, such as the <a href="http://en.wikipedia.org/wiki/Kernel_(computing)"
    target="_blank">[kernel]</a>, <a href="http://en.wikipedia.org/wiki/File_system" target="_blank">
    [file system]</a>, and the
    <a href="http://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/5_CPU_Scheduling.html" target="_blank">
    [scheduler]</a>.  Here is a <b>very good</b> set of slides on the topic of the
    <a href="http://www.ics.uci.edu/~bic/os/" target="_blank">[fundamentals of modern operating systems]</a>, from
    professor Lubomir Bic at the University of California Irvine.
</p>
<p>
    Moreover, you will need to understand <a href="http://en.wikipedia.org/wiki/Process_(computing)"
    target="_blank">[processes]</a> and <a href="http://en.wikipedia.org/wiki/Thread_(computing)" target="_blank">
    [threads]</a>. Speaking of which, do you know the distinction between a process and a thread?
</p>
<p>
    The discussion of threading will undoubtedly raise the inherent issues of
    <a href="http://en.wikipedia.org/wiki/Concurrency_(computer_science)" target="_blank">[concurrency]</a>. You
    will need to know what they are, how they arise, and how to avoid them.  Here are some good resources on
    concurrency:

    <ul>
        <li>
            Chapter 2 from Dr. Bic's slides discusses the topic of
            <a href="http://www.ics.uci.edu/~bic/os/Pajarola/Ch02.pdf" target="_blank">[processes and
            interactions]</a>.
        </li>
        <li>This is a very good overview of the
            <a href="http://sce.uhcl.edu/helm/rationalunifiedprocess/process/workflow/ana_desi/co_cncry.htm"
            target="_blank">[concept of concurrency]</a>.
        </li>
        <li>This article talks about the <a href="http://msdn.microsoft.com/en-us/magazine/cc817398.aspx"
            target="_blank">[hazards of concurrency in coding]</a> and details solutions for 11 different problems
            that you're likely to experience in your multithreaded program.  The examples are given in C#.
        </li>
    </ul>
</p>
<p>
    You should also be aware of the fundamentals of "modern" concurrency constructs. Be able to program a
    simple multithreaded problem in your primary programming language.  I found the following resources for Java:
    <a href="http://gee.cs.oswego.edu/dl/cpj/mechanics.html" target="_blank">[Java concurrency constructs]</a>,
    <a href="http://www.slideshare.net/bje/modern-concurrency-v2" target="_blank">[a unique take on Java
    concurrency]</a>, and
    <a href="http://www.javaworld.com/article/2078679/java-concurrency/modern-threading-for-not-quite-beginners.html"
    target="_blank">[Java concurrency pitfalls]</a>.
</p>



{% assign count = count | plus:1 %}
<h2>{{count}}.&nbsp;Mathematics</h2>
<p>
    It was emphasized to me that counting problems, probability problems, and other Discrete Math 101 problems are
    especially prevalent at Google, which means it is certainly a good idea to brush up on your math.
</p>
<p>
    I think
    <a href="http://en.wikipedia.org/wiki/Combination" target="_blank">[combination]</a> and
    <a href="http://en.wikipedia.org/wiki/Permutation" target="_blank">[permutation]</a> problems are quite
    popular since they are very relatable to coding problems.  For example, you might be asked to
    find all <a href="http://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/"
                target="_blank">[permutations of a string]</a> - a classic permutation problem with many real-world applications.
</p>
<p>
    In my line of research, statistics and probabilities are extremely important!  Knowing basic statistics and
    probability theories will carry you far.  Time permitted, you should fortify your statistics.
</p>
<p>
    Lastly, if you have the time for it, here's a good site that covers various aspects of
    <a href="http://math.about.com/od/discretemath/" target="_blank">[discrete mathematics]</a>.
</p>



{% assign count = count | plus:1 %}
<h2>{{count}}.&nbsp;Googleology</h2>
<p>
    This section is more relevant to Google interviews.  That said, as Google is often considered to be one of the
    leading figures in our field, I wouldn't be surprised to find other companies asking Google related questions
    in their interviews.
</p>
<p>
    It is a good idea to familiarise yourself with the designs of Google systems.  Acknowledge that a great amount of
    innovations on how to deal with big data have found its way out of Google's research labs.  Here is a small
    sample of some important ones (as suggested by a Google recruiter):

    <ul>
        <li>Information on System Design:
            <a href="http://research.google.com/pubs/DistributedSystemsandParallelComputing.html"
            target="_blank">http://research.google.com/pubs/DistributedSystemsandParallelComputing.html</a>
        </li>
        <li>Google File System: <a href="http://research.google.com/archive/gfs.html" target="_blank">
            http://research.google.com/archive/gfs.html</a>
        </li>
        <li>Google Bigtable: <a href="http://research.google.com/archive/bigtable.html" target="_blank">
            http://research.google.com/archive/bigtable.html</a>
        </li>
        <li> Google MapReduce: <a href="http://research.google.com/archive/mapreduce.html" target="_blank">
            http://research.google.com/archive/mapreduce.html</a>
        </li>
    </ul>
</p>
<p>
    If you find yourself wanting to know more about the works of the industry-leading giant, feel free to review some
    more <a href="http://research.google.com/pubs/papers.html" blank="_blank">[Google research publications]</a>.
    Needless to say, these are especially important if you're applying for a research position.
</p>



{% assign count = count | plus:1 %}
<h2>{{count}}.&nbsp;Example Questions, Experiences, and Guides</h2>
<p>
    Finally, I think it's important to get plenty of practice answering interview questions.  Experience
    is invaluable and practice makes perfect!  You should spend any extra time going over example exercises.
    There are many resources available for you on the web.  Here are a few good ones to get
    you started:

    <ul>
        <li>
            Steve Yegge wrote a very nice article about the
            <a href="https://sites.google.com/site/steveyegge2/five-essential-phone-screen-questions" target="_blank">
            [five essential phone-screen questions]</a>. It's short and worth a read.
        </li>
        <li>Topcode.com is a good source for <a href="http://www.topcoder.com/tc?module=Static&d1=tutorials&d2=alg_index"
            target="_blank">[algorithm problems]</a> that Google tends to ask.
        </li>
        <li>Geeksforgeeks.org provides a very good list of <a href="http://www.geeksforgeeks.org/tag/interview-experience/"
            target="_blank">[interview experiences]</a>.
        </li>
        <li>Glassdoor.com also has some interview questions shared by past
            <a href="http://www.glassdoor.com/Interview/Google-Interview-Questions-E9079.htm" target="_blank">
            [Google interviewees]</a>.
        </li>
        <li>
            Businessinsider.com has a list of
            <a href="http://www.businessinsider.com/answers-to-15-google-interview-questions-that-will-make-you-feel-stupid-2010-11?op=1"
            target="_blank">[15 interesting Google interview questions]</a>.  They're mostly estimation or riddle types
            of questions. I am not sure how common they are in actual interviews, but they make for good brain
            exercises.
        </li>
        <li>Javarevisited.blogspot.com composed a nice list of
            <a href="http://javarevisited.blogspot.com/2011/06/top-programming-interview-questions.html"
            target="_blank">[Java interview questions]</a>.
        </li>
    </ul>
</p>
<p>
    Also, don't pass up the chance to read experiences & guides shared by others who have gone through the process.
    Their insights could be the edge you need to get ahead of the competition.

    <ul>
        <li><a href="http://www.philosophicalgeek.com/2007/08/12/my-interview-experience-with-google/" target="_blank">
            philosophicalgeek.com</a><span class="quiet">&nbsp;&nbsp;&nbsp;&laquo;&nbsp;&nbsp;&nbsp;Ben Watson</span>
        </li>
        <li><a href="http://www.kegel.com/academy/getting-hired.html" target="_blank">
            www.kegel.com</a><span class="quiet">&nbsp;&nbsp;&nbsp;&laquo;&nbsp;&nbsp;&nbsp;Dan Kegel</span>
        </li>
        <li><a href="http://miki.it/blog/2013/9/18/google-interview-vs-facebook-interview/" target="_blank">
            miki.it/blog</a><span class="quiet">&nbsp;&nbsp;&nbsp;&laquo;&nbsp;&nbsp;&nbsp;Michele Spagnuolo</span>
        </li>
        <li><a href="http://www.globalnerdy.com/2013/10/19/i-has-the-dumb-or-how-i-embarrassed-myself-in-my-interview-with-google/"
            target="_blank">globalnerdy.com</a><span class="quiet">&nbsp;&nbsp;&nbsp;&laquo;&nbsp;&nbsp;&nbsp;Joey Devilla</span>
        </li>
        <li><a href="http://symbo1ics.com/blog/?p=2055" target="_blank">symbo1ics.com</a><span class="quiet">
            &nbsp;&nbsp;&nbsp;&laquo;&nbsp;&nbsp;&nbsp;Robert Smith</span>
        </li>
    </ul>
</p>
<p>
    And lastly, watch this pitch by Google:<br/>
</p>
<p style="text-align: center;">
    <iframe width="480" height="360" src="//www.youtube.com/embed/w887NIa_V9w" frameborder="4" allowfullscreen></iframe>
</p>
<hr/>


<h2>Summary</h2>
<p>
    That's about it for now.  While the list of materials presented here may seem daunting at first, rest assured that
    with good time management and sufficient willpower, it can be done in a reasonable amount of time.  Feel free
    to skip sections that don't apply to you.  The bottom line is, start early and give yourself
    plenty of time to prepare. Proper preparation is the key to success.
</p>
<p>
    Lastly, I wish you the best of luck on your venture.
</p>
<p>
    <i>Did you find my list of resources helpful or have you found some helpful links that I should include?
        Please leave a comment below and let me know about it.</i>
</p>
